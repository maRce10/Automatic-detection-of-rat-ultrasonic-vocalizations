---
title: Detecting rat ultrasonic vocalizations
subtitle: Example code
author: <a href="https://marce10.github.io/">Marcelo Araya-Salas, PhD</a>
date: "`r Sys.Date()`"
toc: true
toc-depth: 2
toc-location: left
number-sections: true
highlight-style: pygments
format:
  html:
    df-print: kable
    code-fold: show
    code-tools: true
    css: qmd.css
editor_options: 
  chunk_output_type: console
---

::: {.alert .alert-success}

# Objetive {.unnumbered .unlisted}

- Example code on how to use _ohun_ to automatically detect rat ultrasonic vocalizations 

::: 

```{r add link to github repo}
#| eval: true
#| output: asis
#| echo: false

# print link to github repo if any
if (file.exists("./.git/config")){
  config <- readLines("./.git/config")
  url <- grep("url",  config, value = TRUE)
  url <- gsub("\\turl = |.git$", "", url)
  if (nchar(url) > 1)
  cat("\nSource code and acoustic data found at [", url, "](", url, ")", sep = "")
  }

```


# Analysis flowchart {.unnumbered .unlisted}

```{mermaid}

flowchart LR
  A("Format</br>sound files") --> B("Detect</br>sounds") 
  B --> C("Measure</br>acoustic features")
  C --> D("Mitigate</br>false positives")
  D --> E("Summarize</br>USVs counts") 

style A fill:#382A5433
style B fill:#395D9C33
style C fill:#3497A933
style D fill:#60CEAC33
style E fill:#DEF5E533

```

# Load packages {.unnumbered .unlisted}

```{r packages}
#| message: false
#| warning: false
#| echo: true

# install sketchy if not installed
if (!requireNamespace("sketchy", quietly = TRUE)) {
    install.packages("sketchy")
}

## add 'developer/' to packages to install from github
x <- c(
    "maRce10/warbleR",
    "ranger",
    "maRce10/ohun"
)

sketchy::load_packages(x)

```

```{r functions and global parameters}
#| eval: true
#| echo: false
#| message: false
#| warning: false

## add 'developer/' to packages to install from github
x <- c(
    "maRce10/warbleR",
    "Rraven",
    "parallel",
    "ranger",
    "kableExtra",
    "DT",
    "maRce10/ohun"
)

sketchy::load_packages(x)

opts_knit$set(root.dir = "..")

options(knitr.kable.NA = '')

print <- function(x) {
    kb <- kable(x, row.names = FALSE, digits = 4, "html")
    kb <- kable_styling(kb,
                        bootstrap_options = c("striped", "hover", "condensed", "responsive"))
    scroll_box(kb, width = "100%")
}

source("~/Dropbox/R_package_testing/warbleR/R/acoustic_activity.R")
```

# Custom function
```{r}

# function to convert seconds to min:s
seg_2_minseg <- function(seg) {
  minutos <- seg %/% 60
  segundos <- seg %% 60
  sprintf("%d:%02d", minutos, segundos)  # 2 digits
}

```


# Prepare sound files

## Set directory with original sound files

- Modify with your own directory paths
```{r}
#| eval: true

# where the original sound files are
sound_file_path <- "./data/raw/sound_files/"

# where to save the consolidated sound files and clips
consolidate_path <- "./data/raw/sound_files/"

# where to save the output data
output_data_path <- "./data/raw"

warbleR_options(wav.path = sound_file_path)

```

These are the sound files used in this example:
```{r}
#| eval: false
#| echo: true

files <- list.files(
    path = sound_file_path,
    full.names = TRUE,
    recursive = TRUE,
    pattern = ".wav$|.wac$|.mp3$|.flac$"
)

```

```{r}
#| eval: true
#| echo: false

files <- list.files(
    path = sound_file_path,
    full.names = TRUE,
    recursive = TRUE,
    pattern = ".wav$|.flac$"
)

files <- grep("consolidated", files, value = TRUE, invert = TRUE)

files
```


## Consolidate sound files

- Put all original sound files in a single folder
```{r}
#| eval: false

dir.create(file.path(consolidate_path, "consolidated_sound_files"))

cns <- consolidate(
    path = sound_file_path,
    dest.path = file.path(consolidate_path, "consolidated_sound_files"),
    parallel = 1,
    file.ext = ".wav$|.flac$"
)

```

## Homogenize sound file format

- Convert flac to wav (if needed)
- Downsample files
- Update sound file directory afterwards
```{r}
#| eval: false

# convert flac to wav
if (any(grepl("\\.flac$", files)))
    warbleR::wav_2_flac(path = file.path(consolidate_path, "consolidated_sound_files"), reverse = TRUE)

fix_wavs(samp.rate = 200, bit.depth = 16, path = file.path(consolidate_path, "consolidated_sound_files"))

warbleR_options(
  wav.path = file.path(consolidate_path, "consolidated_sound_files", "converted_sound_files")
)

```

## Split sound files into 5 min clips

Update sound file directory afterwards

```{r}
#| eval: false

# check files
feature_acoustic_data(path = .Options$warbleR$path)

# segment duration 2 min
clip_duration <- 2 * 60
    
ssf <- split_acoustic_data(sgmt.dur = clip_duration, cores = 1, path = .Options$warbleR$path)

write.csv(ssf, file.path(consolidate_path, "consolidated_sound_files", "converted_sound_files", "5min_clip_info.csv"), row.names = FALSE)

clips_path <- file.path(consolidate_path, "consolidated_sound_files", "converted_sound_files", "clips")

warbleR_options(
  wav.path = clips_path
)

```


```{r}
#| eval: true
#| echo: false

clips_path <- file.path(consolidate_path, "consolidated_sound_files", "converted_sound_files", "clips")

warbleR_options(
  wav.path = clips_path
)
```

# Automatic detection

::: {.panel-tabset}

## 55 kHz with bedding

### Energy detector 

- Uses optimized detection parameters
- Saves results in a RDS file
```{r}
#| eval: false

detection <- energy_detector(
    path = .Options$warbleR$path,
    thinning = 0.5,
    bp = c(35, 90),
    smooth = 1,
    threshold = 2.5,
    hold.time = 3,
    min.duration = 1,
    max.duration = 200,
    cores = 1
)

saveRDS(
    detection,
    file.path(
        output_data_path,
        "detection.RDS"
    )
)

```

### Random forest classification

#### Measure acoustic features

- Save features at the end of the analysis
```{r measure acoustic features}
#| eval: false
#| echo: true

detection <- readRDS(file.path(output_data_path, "detection.RDS"))

# measure spectrographic parameters
spectral_features <- spectro_analysis(
    detection,
    bp = c(35, 85),
    fast = TRUE,
    ovlp = 70,
    parallel = 1
)

# check if any NA
sapply(spectral_features, function(x)
    sum(is.na(x)))

# remove NAs
detection <- detection[complete.cases(spectral_features), ]

spectral_features <- spectral_features[complete.cases(spectral_features), ]

# save acoustic parameters just in case
write.csv(
    spectral_features,
    file.path(output_data_path, "spectral_features.csv"),
    row.names = FALSE
)

```

#### Predict based on pre-defined RF model

- Download model from figshare
```{r}
#| eval: false
#| echo: true

model_rds <- tempfile()

# this downloads the 55 kHz USV with bedding detection model
download.file(url = "https://figshare.com/ndownloader/files/57261971", destfile = model_rds)

```

```{r}
#| eval: true
#| echo: false

detection <- readRDS(file.path(output_data_path, "detection.RDS"))

model_rds <- "./data/processed/random_forest_55kHz_with_bedding.RDS"

```


## 55 kHz without bedding

### Energy detector 

- Uses optimized detection parameters
- Saves results in a RDS file
```{r}
#| eval: false

detection <- energy_detector(
    path = .Options$warbleR$path,
    thinning = 0.5,
    bp = c(35, 90),
    smooth = 5,
    threshold = 1,
    hold.time = 5,
    min.duration = 1,
    max.duration = 150,
    cores = 1
)

saveRDS(
    detection,
    file.path(
        output_data_path,
        "detection.RDS"
    )
)

```

### Random forest classification

#### Measure acoustic features

- Save features at the end of the analysis
```{r measure acoustic features 55 kHz no bedding}
#| eval: false
#| echo: true

detection <- readRDS(file.path(output_data_path, "detection.RDS"))

# measure spectrographic parameters
spectral_features <- spectro_analysis(
    detection,
    bp = c(35, 85),
    fast = TRUE,
    ovlp = 70,
    parallel = 1
)

# check if any NA
sapply(spectral_features, function(x)
    sum(is.na(x)))

# remove NAs
detection <- detection[complete.cases(spectral_features), ]

spectral_features <- spectral_features[!complete.cases(spectral_features), ]

# save acoustic parameters just in case
write.csv(
    spectral_features,
    file.path(output_data_path, "spectral_features.csv"),
    row.names = FALSE
)

```

#### Predict based on pre-defined RF model

- Download model from figshare
```{r}
#| eval: false
#| echo: true

model_rds <- tempfile()

# this downloads the 55 kHz USV without bedding detection model
download.file(url = "https://figshare.com/ndownloader/files/57261968", destfile = model_rds)

```


## 22 kHz without bedding

### Energy detector 

- Uses optimized detection parameters
- Saves results in a RDS file
```{r}
#| eval: false

detection <- energy_detector(
    path = .Options$warbleR$path,
    thinning = 0.5,
    bp = c(20, 30),
    smooth = 17,
    threshold = 2,
    hold.time = 25,
    min.duration = 2,
    max.duration = 300,
    cores = 1
)

saveRDS(
    detection,
    file.path(
        output_data_path,
        "detection.RDS"
    )
)

```

### Random forest classification

#### Measure acoustic features

- Save features at the end of the analysis
```{r measure acoustic features 22 kHz}
#| eval: false
#| echo: true

detection <- readRDS(file.path(output_data_path, "detection.RDS"))

# measure spectrographic parameters
spectral_features <- spectro_analysis(
    detection,
    bp = c(20, 30),
    fast = TRUE,
    ovlp = 70,
    parallel = 1
)

# check if any NA
sapply(spectral_features, function(x)
    sum(is.na(x)))

# remove NAs
detection <- detection[complete.cases(spectral_features), ]

spectral_features <- spectral_features[!complete.cases(spectral_features), ]

# save acoustic parameters just in case
write.csv(
    spectral_features,
    file.path(output_data_path, "spectral_features.csv"),
    row.names = FALSE
)

# resave detections
saveRDS(
    detection,
    file.path(
        output_data_path,
        "detection.RDS"
    )
)
```

#### Predict based on pre-defined RF model

- Download model from figshare
```{r}
#| eval: false
#| echo: true

model_rds <- tempfile()

# this downloads the 22 kHz USV without bedding detection model
download.file(url = "https://figshare.com/ndownloader/files/57261959", destfile = model_rds)

```


:::

* _(from here the code is based on the 55 kHz detection procedure)_

Apply the model to the measured acoustic parameters
```{r run random forest}
#| eval: true
#| echo: true

# read model
rf_model <- readRDS(model_rds)

# read acoustic features
spectral_features <- read.csv(
    file.path(output_data_path, "spectral_features.csv"),
    stringsAsFactors = FALSE
)

# apply model
detection$class <- predict(object = rf_model, data = spectral_features)$predictions

# keep only true positives
filtered_detection <- detection[detection$class == "true.positive", ]

saveRDS(
    filtered_detection,
    file.path(
        output_data_path,
        "random_forest_filtered_detection.RDS"
    )
)

```

# Summarized

## Reassemble detections to original sound files
```{r}
#| eval: true
#| echo: true


# read detections
filtered_detection <- readRDS(file.path(output_data_path, "random_forest_filtered_detection.RDS"))

# read clip information
clip_info <- read.csv(
    file.path(
        consolidate_path,
        "consolidated_sound_files",
        "converted_sound_files",
        "5min_clip_info.csv"
    )
)

# reassemble to original (long) sound files
reass_detec <- reassemble_detection(detection = filtered_detection, Y = clip_info, pb = FALSE)

```

## USV counts per minute

- To get counts for each minute the code uses `hop.size = 60`
```{r}
#| eval: true
#| echo: true

# counts per minute
## include files so it includes those with no detections
count_min <- acoustic_activity(
    X = reass_detec,
    time.window = 60,
    hop.size = 60,
    path =  file.path(consolidate_path, "/consolidated_sound_files/"),
    files = list.files(
        path = file.path(consolidate_path, "/consolidated_sound_files/"),
        pattern = "\\.wav$"
    )
)

# convert to minute rate
count_min$minute <- count_min$start / 60 + 1

wide_count_min <- reshape(count_min[, c("counts", "minute", "sound.files")],
                          direction = "wide",
                          idvar = "sound.files",
                          timevar = "minute")

names(wide_count_min) <- c("sound.files", paste("min", 1:max(count_min$minute)))

wide_count_min$total <- apply(wide_count_min[, -1], 1, sum, na.rm = TRUE)

# print results
wide_count_min
```


### Minute with highest USV count

- Finds the minute with the highest USV count per sound file 
- The function scans across the entire sound file counting sounds every 1 s (`hop.size = 1`)

```{r}
#| eval: true
#| echo: true

# counting
count_high_min <- acoustic_activity(
    X = reass_detec,
    time.window = 60,
    hop.size = 1,
    path = file.path(consolidate_path, "/consolidated_sound_files/")
)

# rate per minute
count_high_min$rate <- count_high_min$rate * 60

# get highest per sound file
sub_count_high_min <- count_high_min[count_high_min$duration == 60, ]

# get the row with the highest rate per sound file
highes_min <- do.call(rbind, lapply(split(sub_count_high_min, sub_count_high_min$sound.files), function(x)
    x[which.max(x$rate), ]))

highes_min$`start (min:s)` <- seg_2_minseg(highes_min$start)
highes_min$`end (min:s)` <- seg_2_minseg(highes_min$end)

# order columns
highes_min <- highes_min[, c(
    "sound.files",
    "start",
    "end",
    "start (min:s)",
    "end (min:s)",
    "duration",
    "counts",
    "rate"
)]

highes_min
```


### Counts before and after a given time

- For the sake of the example, lest's say we introduced a mate into the cage in the middle of the experiment. The following data simulates the mate entry time for each sound file:
```{r}
#| eval: true
#| echo: true

# simulated mate entry times
mate_entry <- data.frame(sound.files = unique(highes_min$sound.files),
                         time = c(56, 64, 68))

mate_entry
```

- We can now count the number of USVs before and after the mate entry time
- The code also counts the number of USVs in the minute right before and right after the mate entry
```{r}
#| eval: true
#| echo: true

# count before and after
out <- lapply(mate_entry$sound.files, function(x) {
    # get the sound file
    sf <- reass_detec[reass_detec$sound.files == x, ]
    
    sf$mid.point <- (sf$end + sf$start) / 2
    
    # get the time of the mate entry
    t <- mate_entry$time[mate_entry$sound.files == x]
    
    # get the calls before and after the mate entry
    before <- sum(sf$mid.point < t)
    after <- sum(sf$mid.point >= t)
    min.before <- sum(sf$mid.point < t & sf$mid.point >= t - 60)
    min.after <- sum(sf$mid.point >= t & sf$mid.point < t + 60)
    
    return(
        data.frame(
            sound.files = x,
            mate.entry = t,
            count.before = before,
            count.after = after,
            count.min.before = min.before,
            count.min.after = min.after
        )
    )
})

counts <- do.call(rbind, out)

counts

```

---

# Session information {.unnumbered .unlisted}

<details>
  <summary>Click to see</summary>
```{r session info}
#| echo: false

# if devtools is installed use devtools::session_info()
if (requireNamespace("devtools", quietly = TRUE)) {
  devtools::session_info()
} else {
  sessionInfo()
}

```
</details>
